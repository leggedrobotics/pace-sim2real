{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#pace-documentation","title":"PACE Documentation","text":"<p>Welcome to the documentation for PACE (Precise Adaptation through Continuous Evolution), a systematic sim-to-real pipeline for diverse legged robots.</p> <p>PACE provides unified tools for accurate actuator modeling, automatic system identification for seamless deployment of RL controllers to real hardware.</p>      \u25b6 Watch full video on YouTube    <p>Use this documentation to get started, explore examples, and understand how to adapt PACE to your own robot platforms.</p>"},{"location":"#documentation-structure","title":"Documentation structure","text":"<ul> <li>Getting started \u2013 prerequisites, installation, and your first steps with PACE.</li> <li>Examples \u2013 minimal scripts demonstrating parameter identification and deployment on the public version of ANYmal.</li> <li>Guides \u2013 higher-level guides that walk through typical workflows:<ul> <li>Basics \u2013 step-by-step setup of your own PACE environment.</li> <li>Advanced \u2013 extending the framework with custom objectives, parameters, and optimization logic.</li> <li>Best practices \u2013 practical recommendations, guidelines, and common pitfalls.</li> </ul> </li> </ul> <p>Additional sections such as Concepts, API Reference, and Development are planned and will be added as the PACE framework evolves.</p>"},{"location":"#how-to-cite","title":"How to cite","text":"<p>If you use PACE in your research, please cite our paper:</p> <p>F. Bjelonic, F. Tischhauser, and M. Hutter, Towards Bridging the Gap: Systematic Sim-to-Real Transfer for Diverse Legged Robots, arXiv:2509.06342, 2025.</p> <pre><code>@article{bjelonic2025towards,\n  title         = {Towards Bridging the Gap: Systematic Sim-to-Real Transfer for Diverse Legged Robots},\n  author        = {Bjelonic, Filip and Tischhauser, Fabian and Hutter, Marco},\n  journal       = {arXiv preprint arXiv:2509.06342},\n  year          = {2025},\n  eprint        = {2509.06342},\n  archivePrefix = {arXiv},\n  primaryClass  = {cs.RO},\n}\n</code></pre>"},{"location":"404/","title":"Page not found","text":"<p>The page you are looking for does not exist or will be part of the documentation in a future release.</p>"},{"location":"importing/","title":"Importing PACE","text":"<p>This section explains the recommended way to import the <code>pace_sim2real</code> package in your own projects.</p> <p>The import structure is intentionally designed to:</p> <ul> <li>keep the public API clean and future-proof,</li> <li>separate user-facing interfaces from internal implementation details,</li> <li>avoid accidental reliance on unstable deep module paths.</li> </ul>"},{"location":"importing/#recommended-public-imports","title":"Recommended public imports","text":"<p>For most use cases, you should import directly from the top-level package:</p> <pre><code>from pace_sim2real import (\n    PaceSim2realEnvCfg,\n    PaceSim2realSceneCfg,\n    PaceCfg,\n    CMAESOptimizer,\n)\n</code></pre> <p>These symbols form the official public API of PACE.</p>"},{"location":"importing/#utilities-and-helper-modules","title":"Utilities and helper modules","text":"<p>Lower-level actuator models are intentionally namespaced under <code>utils</code> and should be imported explicitly:</p> <pre><code>from pace_sim2real.utils import (\n    PaceDCMotorCfg,\n    PaceDCMotor,\n)\n</code></pre>"},{"location":"importing/#isaaclab-environment-registration","title":"IsaacLab environment registration","text":"<p>To make PACE environments available in the Gym / IsaacLab registry, the task package must be imported after the simulator is launched.</p> <pre><code>import pace_sim2real.tasks  # Registers PACE environments\n</code></pre> <p>A typical usage pattern looks like this:</p> <pre><code>from isaaclab.app import AppLauncher\nfrom pace_sim2real import PaceCfg\n\n# Launch Isaac Sim / Omniverse\napp_launcher = AppLauncher(args_cli)\nsimulation_app = app_launcher.app\n\n# Register PACE environments\nimport pace_sim2real.tasks\n</code></pre> <p>After this, environments such as <code>Isaac-Pace-Anymal-D-v0</code> become available.</p>"},{"location":"importing/#framework-evolution-stability","title":"Framework evolution &amp; stability","text":"<p>PACE is an actively evolving research framework. While we aim for long-term stability, parts of the system may change as new capabilities, robots, and workflows are integrated.</p>"},{"location":"importing/#what-you-should-expect","title":"What you should expect","text":"<ul> <li> <p>The core concepts and philosophy of PACE will remain consistent.</p> </li> <li> <p>The public API is designed to be stable, but may receive deprecations or refinements as the framework matures.</p> </li> <li> <p>Internal implementation details and experimental features may change more frequently.</p> </li> </ul>"},{"location":"importing/#we-follow-a-best-effort-approach-to","title":"We follow a best-effort approach to:","text":"<ul> <li> <p>clearly communicate breaking changes in release notes,</p> </li> <li> <p>provide migration hints when applicable,</p> </li> <li> <p>keep examples and documentation aligned with the latest recommended usage.</p> </li> </ul> <p>If you build long-term projects on top of PACE, we recommend pinning a specific version and consulting the changelog when upgrading.</p>"},{"location":"installation/","title":"Installation","text":"<p>This section describes how to install and set up the PACE (Precise Adaptation through Continuous Evolution) framework on your system. PACE is built on top of NVIDIA Isaac Lab and requires a working GPU-accelerated simulation environment.</p>"},{"location":"installation/#system-requirements","title":"System Requirements","text":""},{"location":"installation/#supported-operating-systems","title":"Supported Operating Systems","text":"<ul> <li>Ubuntu 20.04 or newer (tested and recommended: Ubuntu 22.04)</li> </ul>"},{"location":"installation/#hardware","title":"Hardware","text":"<ul> <li>NVIDIA GPU with CUDA support (RTX series recommended)</li> <li>At least 8 GB GPU memory (16 GB recommended for large-scale experiments)</li> <li>16 GB system RAM (32 GB recommended)</li> </ul>"},{"location":"installation/#software","title":"Software","text":"<ul> <li>NVIDIA Driver</li> <li>CUDA Toolkit (compatible with your Isaac Sim version)</li> <li>Python &gt;= 3.10</li> <li>Git</li> </ul> <p>PACE is developed and tested with Isaac Sim 5.0, Isaac Lab 0.46.2 and Python 3.11.13. Other versions may work but are not officially supported at the moment.</p>"},{"location":"installation/#isaac-sim-compatibility-notes","title":"Isaac Sim compatibility notes","text":"<p>PACE is designed around the physics capabilities introduced in Isaac Sim 5.0, including: - Joint viscous friction modeling - Improved articulation parameter handling - More consistent actuator behavior</p> <p>When running PACE on Isaac Sim versions &lt; 5.0, you may see warnings such as:</p> <pre><code>Setting joint viscous friction coefficients are not supported in Isaac Sim &lt; 5.0\n</code></pre> <p>This means the simulator silently ignores these parameters. As a result: - The simulation will run, but - The actuator dynamics will not match the intended PACE model - Sim-to-real performance may degrade</p> <p>For accurate system identification and controller transfer, we strongly recommend using:</p> <p>Isaac Sim 5.0 + Isaac Lab (current stable)</p> <p>Future versions of PACE may rely even more heavily on features introduced in Isaac Sim 5.x.</p>"},{"location":"installation/#1-install-isaac-lab","title":"1. Install Isaac Lab","text":"<p>PACE is implemented as an extension for Isaac Lab. Please follow the official Isaac Lab installation instructions first:</p> <p>\ud83d\udc49 https://isaac-sim.github.io/IsaacLab/</p>"},{"location":"installation/#2-clone-the-pace-repository","title":"2. Clone the PACE repository","text":"<p>Clone the PACE repository (outside of IsaacLab):</p> <pre><code>cd ~\ngit clone https://github.com/leggedrobotics/pace-sim2real.git\n</code></pre>"},{"location":"installation/#3-install-the-pace-extension","title":"3. Install the PACE extension","text":"<p>Activate your Conda environment and install PACE</p> <pre><code>cd ~/pace-sim2real\n# use 'PATH_TO_isaaclab.sh|bat -p' instead of 'python' if Isaac Lab is not installed in Python venv or conda\npython -m pip install -e source/pace_sim2real\n</code></pre> <p>All required Python dependencies (including CMA-ES) are installed automatically during this step.</p> <p>You are now ready to run PACE \ud83d\ude80</p> <p>Proceed to:</p> <ul> <li>Examples \u2013 run your first experiment</li> <li>Guids \u2013 how to set up your own robot and tasks</li> <li>Concepts \u2013 core ideas behind PACE and sim-to-real transfer</li> </ul>"},{"location":"usage/","title":"Basic Usage","text":"<p>This section provides a brief overview of the main PACE scripts and their most important command-line arguments. It is intended as a quick reference for running common workflows, without going into full implementation or theory details.</p> <p>The typical workflow consists of:</p> <ol> <li>Collecting excitation data from the robot or simulation</li> <li>Running parameter identification using CMA-ES</li> <li>Visualising and analysing the resulting trajectories and scores</li> </ol>"},{"location":"usage/#overview-of-main-scripts","title":"Overview of main scripts","text":"Script Purpose <code>data_collection.py</code> Collects excitation data using a chirp signal for system identification <code>fit.py</code> Runs the PACE parameter identification using CMA-ES <code>plot_trajectory.py</code> Visualises the resulting trajectories and optimization progress"},{"location":"usage/#1-data-collection","title":"1. Data collection","text":"<pre><code>python scripts/pace/data_collection.py\n</code></pre> <p>This script generates excitation trajectories using a chirp signal and records the corresponding robot states for later parameter identification.</p>"},{"location":"usage/#common-arguments","title":"Common arguments","text":"Argument Description <code>--num_envs</code> Number of parallel simulation environments <code>--task</code> Name of the task / robot configuration <code>--min_frequency</code> Minimum frequency of the chirp signal (Hz) <code>--max_frequency</code> Maximum frequency of the chirp signal (Hz) <code>--duration</code> Duration of the chirp signal in seconds <code>--device</code> Simulation device: <code>cpu</code>, <code>cuda</code>, or <code>cuda:N</code> <code>--headless</code> Run without rendering"},{"location":"usage/#example","title":"Example","text":"<pre><code>python scripts/pace/data_collection.py \\\n  --task Isaac-Pace-Anymal-D-v0 \\\n  --num_envs 1 \\\n  --min_frequency 0.1 \\\n  --max_frequency 10 \\\n  --duration 20 \\\n  --device cuda\n</code></pre>"},{"location":"usage/#2-parameter-fitting","title":"2. Parameter fitting","text":"<pre><code>python scripts/pace/fit.py\n</code></pre> <p>This script performs system identification using CMA-ES to optimize physical parameters such as armature, damping, friction, bias, and delay.</p>"},{"location":"usage/#common-arguments_1","title":"Common arguments","text":"Argument Description <code>--num_envs</code> Number of simulation environments <code>--task</code> Name of the task / robot <code>--device</code> Simulation device <code>--headless</code> Disable rendering for faster execution"},{"location":"usage/#example_1","title":"Example","text":"<pre><code>python scripts/pace/fit.py \\\n  --task Isaac-Pace-Anymal-D-v0 \\\n  --num_envs 4096 \\\n  --headless\n</code></pre>"},{"location":"usage/#3-plotting-trajectories-and-scores","title":"3. Plotting trajectories and scores","text":"<pre><code>python scripts/pace/plot_trajectory.py\n</code></pre> <p>This utility visualises the optimized trajectory and/or the evolution of the score over iterations. If no <code>folder_name</code> argument is given, the script will use the most recent evolution.</p>"},{"location":"usage/#common-arguments_2","title":"Common arguments","text":"Argument Description <code>--folder_name</code> Name of the optimization output folder <code>--mean_name</code> Name of the parameter file (e.g. <code>mean_020.pt</code>) <code>--robot_name</code> Name of the robot <code>--plot_trajectory</code> Plot the optimized joint trajectories <code>--plot_score</code> Plot the score over iterations"},{"location":"usage/#example_2","title":"Example","text":"<pre><code>python scripts/pace/plot_trajectory.py \\\n  --folder_name 24_03_12_14-32-10 \\\n  --robot_name anymal_d_sim \\\n  --plot_trajectory \n</code></pre>"},{"location":"usage/#notes","title":"Notes","text":"<ul> <li>All scripts share common Isaac Lab launcher arguments such as <code>--headless</code>, <code>--livestream</code>, and <code>--rendering_mode</code>.</li> <li>For full argument lists, run any script with:</li> </ul> <pre><code>python script_name.py --help\n</code></pre> <p>More advanced workflows and in-depth explanations are covered in the Examples and Guides sections.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/optim/","title":"Optimization API","text":""},{"location":"api/optim/#cmaesoptimizer","title":"CMAESOptimizer","text":"<p>::: pace_sim2real.optim.cma_es.CMAESOptimizer     options:       show_source: false       members_order: source</p>"},{"location":"concepts/actuators/","title":"Actuators","text":"<p>Coming soon.</p>"},{"location":"dev/contributing/","title":"Contributing","text":"<p>Coming soon.</p>"},{"location":"examples/","title":"Examples","text":"<p>This section demonstrates practical use-cases of the PACE pipeline, from data collection to sim-to-real parameter identification and evaluation.</p> <p>The examples are designed to help you understand how to apply PACE to real robotic systems and adapt the workflow to your own platforms.</p> <p>Currently, one complete example is provided for ANYmal, showcasing the full pipeline in a reproducible and realistic setting. Additional examples for other robots and scenarios are planned and will be added as the framework evolves.</p>      4096 ANYmal D robots running in parallel during PACE system identification."},{"location":"examples/anymal/","title":"ANYmal Example: PACE Workflow","text":"<p>This section demonstrates the complete PACE workflow using ANYmal as an example platform. While the data collection is typically performed directly on the real robot hardware, we present the full pipeline in simulation to illustrate the process and enable safe testing and validation prior to hardware deployment.</p>"},{"location":"examples/anymal/#data-collection","title":"Data Collection","text":"<p>This step generates excitation data required for evolutionary parameter identification. The procedure fixes ANYmal in mid-air and applies a crafted feed-forward joint-space trajectory designed to excite all joints simultaneously.</p>"},{"location":"examples/anymal/#trajectory-description","title":"Trajectory description","text":"<ul> <li>Duration: 20 seconds</li> <li>Signal type: Chirp trajectory</li> <li>Frequency range: 0.1 \u2013 10 Hz</li> <li>All joints are excited concurrently</li> </ul> <p>The following physical properties are configured to closely match the estimated parameters of the real ANYmal hardware:</p> <ul> <li>Joint armature</li> <li>Viscous damping</li> <li>Static friction</li> <li>Joint bias</li> <li>Actuator delay</li> </ul> <p>This setup allows realistic synthetic data generation while avoiding risk to the real system.</p>"},{"location":"examples/anymal/#execution","title":"Execution","text":"<p>Inside the virtual environment, run:</p> <pre><code>cd ~/pace-sim2real\npython scripts/pace/data_collection.py\n</code></pre> <p></p> <p>The collected data is saved in:</p> <pre><code>pace-sim2real/data/anymal_d_sim/chirp_data.pt\n</code></pre> <p>This dataset serves as the input for the PACE optimization pipeline.</p>"},{"location":"examples/anymal/#evolutionary-parameter-identification","title":"Evolutionary Parameter Identification","text":"<p>This step runs the PACE evolutionary optimization to identify actuator and joint parameters that best match the recorded trajectory.</p>"},{"location":"examples/anymal/#configuration","title":"Configuration","text":"<ul> <li>Number of environments: 4096</li> <li> <p>Total identified parameters: 49</p> <ul> <li>12 joint armature values</li> <li>12 viscous friction values</li> <li>12 static friction values</li> <li>12 joint bias values</li> <li>1 global delay</li> </ul> </li> </ul> <p>In this example, the optimizer re-estimates the parameters used in the simulation data collection stage, serving as a proof-of-correctness. In real deployments, this step is used to identify parameters of custom hardware platforms.</p>"},{"location":"examples/anymal/#execution_1","title":"Execution","text":"<p>Inside the virtual environment, run:</p> <pre><code>cd ~/pace-sim2real\npython scripts/pace/fit.py --headless\n</code></pre> <p>The optimization progress can be monitored using TensorBoard in:</p> <pre><code>pace-sim2real/logs/pace/anymal_d_sim\n</code></pre> <p></p>"},{"location":"examples/anymal/#performance","title":"Performance","text":"<ul> <li>Convergence: up to numerical precision (~1e-12)</li> <li>Runtime: approximately 2:15 hours on an NVIDIA RTX 3080</li> </ul> <p>Empirically, final scores below 0.005 indicate a high-quality fit and typically lead to strong sim-to-real transfer performance (e.g. ANYmal using real data is below 0.003, compare paper Figure 9.).</p> <p> </p> <p></p>"},{"location":"examples/anymal/#testing-the-identified-parameters","title":"Testing the Identified Parameters","text":"<p>This step evaluates the optimized parameters by visualizing the best-matching trajectory.</p> <p>The script:</p> <ul> <li>Plots the best simulated trajectory</li> <li>Compares it with the original collected data</li> <li>Prints the evolution of the best parameters across iterations</li> </ul>"},{"location":"examples/anymal/#execution_2","title":"Execution","text":"<p>Inside the virtual environment, run:</p> <pre><code>cd ~/pace-sim2real\npython scripts/pace/plot_trajectory.py --plot_trajectory\n</code></pre> <p>This provides a final verification step before deploying parameters into a learning or control pipeline.</p>"},{"location":"examples/anymal/#deploying-on-hardware","title":"Deploying on Hardware","text":"<p>To use the identified parameters in your learning environment, integrate the PACE actuator model into your project.</p> <p>Copy the following files (or directly import them in your learning environment):</p> <ul> <li><code>pace-sim2real/source/pace_sim2real/pace_sim2real/utils/pace_actuator.py</code></li> <li><code>pace-sim2real/source/pace_sim2real/pace_sim2real/utils/pace_actuator_cfg.py</code></li> </ul> <p>Use the following procedure:</p> <ol> <li>Import <code>PaceDCMotor</code> and <code>PaceDCMotorCfg</code> into your project.</li> <li> <p>During initialization, set:</p> <ul> <li>Joint delay</li> <li>Joint bias</li> </ul> <p>using the values obtained from the parameter identification step.</p> </li> <li> <p>Prior to training, configure your articulation object with the optimized parameters for:</p> <ul> <li><code>joint_armature</code></li> <li><code>joint_viscous_friction</code></li> <li><code>joint_friction</code></li> </ul> </li> </ol>"},{"location":"examples/anymal/#recommended-validation-step","title":"Recommended validation step","text":"<p>Before training locomotion policies, we recommend replaying the collected real-world data within your learning environment. This serves as an additional sanity check to ensure the simulation faithfully reproduces the system dynamics prior to policy optimization.</p>"},{"location":"tutorials/advanced/","title":"Advanced Tutorial: Tailoring the Optimization to Your Needs","text":"<p>This advanced tutorial explains how to customize and extend the PACE optimization pipeline for specialized research and hardware requirements. It is intended for users who want to go beyond the default setup and adapt the evolutionary process to their specific system identification or sim-to-real objectives.</p> <p>The core optimization logic of PACE is implemented in:</p> <pre><code>pace-sim2real/source/pace_sim2real/pace_sim2real/optim/cma_es.py\n</code></pre> <p>This file defines the <code>CMAESOptimizer</code> class, which orchestrates population sampling, evaluation, simulator parameter updates, convergence monitoring, and logging. Understanding and modifying this class enables fine-grained control over the entire identification process.</p> <p>The class can be imported using <pre><code>from pace_sim2real import CMAESOptimizer\n</code></pre></p>"},{"location":"tutorials/advanced/#extension-strategies","title":"Extension Strategies","text":"<p>Advanced users typically follow one of two approaches:</p>"},{"location":"tutorials/advanced/#1-inherit-and-extend","title":"1. Inherit and extend","text":"<p>Create a new optimizer file in the same directory and inherit from <code>CMAESOptimizer</code>:</p> <pre><code>class CustomCMAESOptimizer(CMAESOptimizer):\n    def tell(self, sim_dof_pos, real_dof_pos):\n        # Custom loss or scoring logic\n        pass\n</code></pre> <p>This maintains compatibility with future PACE updates while allowing isolated customization.</p>"},{"location":"tutorials/advanced/#2-direct-modification","title":"2. Direct modification","text":"<p>Modify <code>cma_es.py</code> directly if you need tight integration or experimental changes that deviate significantly from the default interface.</p> <p>This is useful for:</p> <ul> <li>Research prototypes</li> <li>Heavily custom cost functions</li> <li>Alternative parameter representations</li> </ul>"},{"location":"tutorials/advanced/#understanding-the-optimization-pipeline","title":"Understanding the Optimization Pipeline","text":"<p>Each CMA-ES generation follows the sequence:</p> <ol> <li>ask() \u2013 Sample a population of normalized parameters</li> <li>Simulator Update \u2013 Apply parameters to simulator</li> <li>Simulation Rollout \u2013 Generate joint trajectories</li> <li>tell(...) \u2013 Accumulate score over trajectories</li> <li>evolve() \u2013 CMA-ES update step</li> <li>Logging + Checkpointing</li> </ol> <p>This loop continues until either:</p> <ul> <li><code>max_iteration</code> is reached, or</li> <li>Convergence is detected via <code>epsilon</code></li> </ul>"},{"location":"tutorials/advanced/#changing-the-optimization-objective","title":"Changing the Optimization Objective","text":"<p>The default objective minimizes joint position tracking error with bias compensation:</p> <pre><code>def tell(self, sim_dof_pos, real_dof_pos):\n    self.scores += torch.sum(torch.square(sim_dof_pos - real_dof_pos - self.sim_params[:, self.bias_idx]), dim=1)\n</code></pre> <p>Advanced objectives can be implemented inside the <code>tell()</code> method.</p>"},{"location":"tutorials/advanced/#examples","title":"Examples","text":""},{"location":"tutorials/advanced/#weighted-joint-position-velocity","title":"Weighted joint position + velocity","text":"<pre><code>error_pos = torch.sum((sim_dof_pos - real_dof_pos)**2, dim=1)\nerror_vel = torch.sum((sim_dof_vel - real_dof_vel)**2, dim=1)\nself.scores += 0.7 * error_pos + 0.3 * error_vel\n</code></pre>"},{"location":"tutorials/advanced/#velocity-only-identification","title":"Velocity-only identification","text":"<pre><code>self.scores += torch.sum((sim_dof_vel - real_dof_vel)**2, dim=1)\n</code></pre>"},{"location":"tutorials/advanced/#end-effector-error","title":"End-effector error","text":"<pre><code>error = torch.norm(sim_ee_pose - real_ee_pose, dim=1)\nself.scores += error\n</code></pre> <p>This allows optimization tailored to:</p> <ul> <li>Contact dynamics</li> <li>Compliance tuning</li> <li>Task-space behavior</li> </ul>"},{"location":"tutorials/advanced/#adding-or-modifying-optimized-parameters","title":"Adding or Modifying Optimized Parameters","text":"<p>By default, the optimizer tunes:</p> <ul> <li>Joint armature</li> <li>Viscous damping</li> <li>Coulomb friction</li> <li>Encoder bias</li> <li>Encoder delay</li> </ul> <p>The parameter vector is structured as:</p> <pre><code>[ armature | damping | friction | bias | delay ]\n</code></pre>"},{"location":"tutorials/advanced/#adding-new-parameters","title":"Adding new parameters","text":"<p>For example, to add torque saturation:</p> <ol> <li>Extend bounds tensor</li> <li>Increase param dimensionality</li> <li>Add index slices</li> <li>Apply to simulator in <code>update_simulator()</code></li> </ol> <p>Example:</p> <pre><code>torque_limit_idx = slice(5 * num_joints, 6 * num_joints)\n</code></pre> <p>Then write into the simulator accordingly.</p>"},{"location":"tutorials/advanced/#parameter-normalization-strategy","title":"Parameter Normalization Strategy","text":"<p>All CMA-ES parameters operate in normalized space \u2208 [-1, 1]. These are mapped to physical values via:</p> <pre><code>sim_params = bounds_min + (params + 1)/2 * (bounds_max - bounds_min)\n</code></pre> <p>This ensures numerical stability and consistent scaling across heterogeneous parameters.</p>"},{"location":"tutorials/advanced/#convergence-control","title":"Convergence Control","text":"<p>Stopping occurs when:</p> <ul> <li><code>iteration &gt;= max_iteration</code></li> <li>OR score variance &lt; epsilon</li> </ul> <p>The metric used:</p> <pre><code>(max_score - min_score) / min_score\n</code></pre> <p>You may replace this with more sophisticated criteria such as:</p> <ul> <li>Fitness gradient threshold</li> <li>Moving average plateaus</li> <li>Early stopping windows</li> </ul>"},{"location":"tutorials/advanced/#logging-monitoring","title":"Logging &amp; Monitoring","text":"<p>TensorBoard metrics recorded include:</p> <ul> <li>Parameter distributions per joint</li> <li>Best parameter evolution</li> <li>Score curves</li> <li>Delay histograms</li> </ul> <p>Checkpoints saved:</p> <ul> <li>Best trajectory (<code>best_trajectory.pt</code>)</li> <li>Mean parameters</li> <li>Full progress (optional)</li> </ul> <p>This enables:</p> <ul> <li>Offline analysis</li> <li>Reproducibility</li> <li>Debugging of convergence behavior</li> </ul>"},{"location":"tutorials/advanced/#common-pitfalls-and-tips","title":"Common Pitfalls and Tips","text":"<ul> <li>Avoid multi-scale parameters without normalization</li> <li>Ensure score magnitude remains stable across iterations</li> <li>Use histograms to detect parameter collapse</li> <li>Do not mix physical units inside loss</li> </ul>"},{"location":"tutorials/advanced/#recommended-workflow-for-custom-optimizers","title":"Recommended Workflow for Custom Optimizers","text":"<ol> <li>Clone base implementation</li> <li>Define new loss component</li> <li>Visualize score evolution</li> <li>Analyze parameter histograms</li> <li>Validate on multiple trajectories</li> <li>Deploy to hardware carefully</li> </ol>"},{"location":"tutorials/advanced/#summary","title":"Summary","text":"<p>The CMA-ES optimizer in PACE is designed for extensibility, transparency, and research flexibility. By customizing its objective, parameters, and convergence logic, users can tailor the system identification process to highly specific real-world challenges \u2014 from actuator modeling to task-specific sim-to-real transfer.</p>"},{"location":"tutorials/basics/","title":"Tutorial: Creating a Custom PACE Environment and Identifying Parameters","text":""},{"location":"tutorials/basics/#overview","title":"Overview","text":"<p>This tutorial explains how to set up a custom robot environment within the PACE (Precise Adaptation through Continuous Evolution) framework in order to estimate the dynamics of your system through evolutionary parameter identification.</p> <p>We will walk through the full pipeline, from defining your environment and actuators, to designing excitation trajectories and running the CMA-ES-based optimization. For clarity and consistency, the examples below use ANYmal as the reference robot. When adapting this tutorial to your own platform, simply replace occurrences of <code>anymal</code> with your robot's name and adjust the corresponding parameters.</p> <p>The tutorial covers:</p> <ul> <li>Creating and configuring a PACE environment</li> <li>Defining actuator models and optimization boundaries</li> <li>Registering the environment with IsaacLab</li> <li>Designing excitation trajectories</li> <li>Running evolutionary parameter fitting</li> <li>Inspecting and comparing optimization results</li> </ul>"},{"location":"tutorials/basics/#creating-the-environment","title":"Creating the Environment","text":"<p>The core of the PACE framework is the definition and registration of a task-specific simulation environment. This environment specifies the robot configuration, its actuators, and the parameter ranges used during system identification.</p> <p>The reference implementation for ANYmal can be found at:</p> <pre><code>pace-sim2real/source/pace_sim2real/pace_sim2real/tasks/manager_based/pace/anymal_pace_env_cfg.py\n</code></pre> <p>This file provides the complete configuration of the robotic system and its associated PACE parameters.</p> <pre><code>from isaaclab.utils import configclass\n\nfrom isaaclab_assets.robots.anymal import ANYMAL_D_CFG\nfrom isaaclab.assets import ArticulationCfg\nfrom pace_sim2real.utils import PaceDCMotorCfg\nfrom pace_sim2real import PaceSim2realEnvCfg, PaceSim2realSceneCfg, PaceCfg\nimport torch\n\nANYDRIVE_PACE_ACTUATOR_CFG = PaceDCMotorCfg(\n    joint_names_expr=[\".*HAA\", \".*HFE\", \".*KFE\"],\n    saturation_effort=140.0,\n    effort_limit=89.0,\n    velocity_limit=8.5,\n    stiffness={\".*\": 85.0},  # P gain in Nm/rad\n    damping={\".*\": 0.6},  # D gain in Nm s/rad\n    encoder_bias=[0.0] * 12,  # encoder bias in radians\n    max_delay=10,  # max delay in simulation steps\n)\n\n\n@configclass\nclass AnymalDPaceCfg(PaceCfg):\n    \"\"\"Pace configuration for Anymal-D robot.\"\"\"\n    robot_name: str = \"anymal_d_sim\"\n    data_dir: str = \"anymal_d_sim/chirp_data.pt\"  # located in pace_sim2real/data/anymal_d_sim/chirp_data.pt\n    bounds_params: torch.Tensor = torch.zeros((49, 2))  # 12 + 12 + 12 + 12 + 1 = 49 parameters to optimize\n    joint_order: list[str] = [\n        \"LF_HAA\",\n        \"LF_HFE\",\n        \"LF_KFE\",\n        \"RF_HAA\",\n        \"RF_HFE\",\n        \"RF_KFE\",\n        \"LH_HAA\",\n        \"LH_HFE\",\n        \"LH_KFE\",\n        \"RH_HAA\",\n        \"RH_HFE\",\n        \"RH_KFE\",\n    ]\n\n    def __post_init__(self):\n        # set bounds for parameters\n        self.bounds_params[:12, 0] = 1e-5\n        self.bounds_params[:12, 1] = 1.0  # armature between 1e-5 - 1.0 [kgm2]\n        self.bounds_params[12:24, 1] = 7.0  # dof_damping between 0.0 - 7.0 [Nm s/rad]\n        self.bounds_params[24:36, 1] = 0.5  # friction between 0.0 - 0.5\n        self.bounds_params[36:48, 0] = -0.1\n        self.bounds_params[36:48, 1] = 0.1  # bias between -0.1 - 0.1 [rad]\n        self.bounds_params[48, 1] = 10.0  # delay between 0.0 - 10.0 [sim steps]\n\n\n@configclass\nclass ANYmalDPaceSceneCfg(PaceSim2realSceneCfg):\n    \"\"\"Configuration for Anymal-D robot in Pace Sim2Real environment.\"\"\"\n    robot: ArticulationCfg = ANYMAL_D_CFG.replace(prim_path=\"{ENV_REGEX_NS}/Robot\", init_state=ArticulationCfg.InitialStateCfg(pos=(0.0, 0.0, 1.0)),\n                                                  actuators={\"legs\": ANYDRIVE_PACE_ACTUATOR_CFG})\n\n\n@configclass\nclass AnymalDPaceEnvCfg(PaceSim2realEnvCfg):\n\n    scene: ANYmalDPaceSceneCfg = ANYmalDPaceSceneCfg()\n    sim2real: PaceCfg = AnymalDPaceCfg()\n\n    def __post_init__(self):\n        # post init of parent\n        super().__post_init__()\n\n        # robot sim and control settings\n        self.sim.dt = 0.0025  # 400Hz simulation\n        self.decimation = 1  # 400Hz control\n</code></pre> <p>The custom environment consists of:</p> <ul> <li>The robot model and its actuators</li> <li>The optimization parameter bounds for CMA-ES</li> <li>PACE-specific configuration linking simulation and real-world data</li> </ul> <p>The following sections describe each component in detail.</p>"},{"location":"tutorials/basics/#creating-the-pace-dc-motors","title":"Creating the PACE DC Motors","text":"<pre><code>ANYDRIVE_PACE_ACTUATOR_CFG = PaceDCMotorCfg(\n    joint_names_expr=[\".*HAA\", \".*HFE\", \".*KFE\"],\n    saturation_effort=140.0,\n    effort_limit=89.0,\n    velocity_limit=8.5,\n    stiffness={\".*\": 85.0},\n    damping={\".*\": 0.6},\n    encoder_bias=[0.0] * 12,\n    max_delay=10,\n)\n</code></pre> <p>ANYmal uses a single drive type, but your robot may employ multiple actuator variants. In such cases, create one <code>PaceDCMotorCfg</code> per actuator type and associate the corresponding joints via <code>joint_names_expr</code>.</p> <p>Key parameters include:</p> <ul> <li><code>saturation_effort</code>: peak torque capability</li> <li><code>effort_limit</code>: hardware-imposed torque limit</li> <li><code>velocity_limit</code>: maximum joint velocity</li> <li><code>stiffness</code> and <code>damping</code>: internal PD gains used by the real actuator</li> <li><code>encoder_bias</code>: initial bias estimate (set to zero initially)</li> <li><code>max_delay</code>: maximum expected actuator delay in simulation steps</li> </ul> <p>If your robot uses a specialized actuator model, you can extend <code>PaceDCMotorCfg</code> by inheriting from your custom class and augmenting it with delay and encoder bias functionality.</p>"},{"location":"tutorials/basics/#defining-pace-specific-configs","title":"Defining PACE specific configs","text":"<pre><code>@configclass\nclass AnymalDPaceCfg(PaceCfg):\n    ...\n</code></pre> <p>The <code>AnymalDPaceCfg</code> block defines algorithmic parameters and data linkage:</p> <ul> <li><code>robot_name</code>: determines logging directory</li> <li><code>data_dir</code>: path to recorded trajectory data</li> <li><code>joint_order</code>: alignment with real data</li> <li><code>bounds_params</code>: optimization limits</li> </ul> <p>Optional CMA-ES settings (iterations, sigma, epsilon, logging frequency) can also be configured here.</p> <p>IsaacLab determines joint ordering via breadth-first traversal, which may differ from the ordering used in your real robot\u2019s control stack or logged data. To ensure correct alignment between simulated and real trajectories, explicitly define the joint order used on your physical system here.</p> <p>PACE normalizes optimization parameters to the range [-1, 1]. However, the physically meaningful parameter limits are defined via <code>bounds_params</code>, which constrains the sampling domain of the CMA-ES optimizer.</p> <p>The parameters are laid out as:</p> <ul> <li>Armature: <code>[0 : n_joints]</code></li> <li>Viscous friction: <code>[n_joints : 2*n_joints]</code></li> <li>Static friction: <code>[2*n_joints : 3*n_joints]</code></li> <li>Encoder bias: <code>[3*n_joints : 4*n_joints]</code></li> <li>Global delay: <code>[-1]</code></li> </ul> <pre><code>def __post_init__(self):\n        # set bounds for parameters\n        ...\n</code></pre> <p>The values should be chosen conservatively based on hardware knowledge or prior estimates, and can be refined iteratively as needed.</p>"},{"location":"tutorials/basics/#creating-the-scene","title":"Creating the Scene","text":"<pre><code>@configclass\nclass ANYmalDPaceSceneCfg(PaceSim2realSceneCfg):\n    ...\n</code></pre> <p>Here, you inherit from <code>PaceSim2realSceneCfg</code> and specify your robot USD, initial pose, and associated actuators. Ensure the initial height prevents ground penetration or unwanted contacts. Actuator naming is flexible and purely user-defined.</p>"},{"location":"tutorials/basics/#registering-the-environment","title":"Registering the Environment","text":"<p>To expose the environment to the optimization pipeline, it must be registered within IsaacLab\u2019s task registry:</p> <pre><code>pace-sim2real/source/pace_sim2real/pace_sim2real/tasks/manager_based/__init__.py\n</code></pre> <p>Following the naming convention <code>Isaac-Pace-&lt;robot&gt;-v0</code>:</p> <pre><code>gym.register(\n    id=\"Isaac-Pace-Anymal-D-v0\",\n    entry_point=\"isaaclab.envs:ManagerBasedRLEnv\",\n    disable_env_checker=True,\n    kwargs={\n        \"env_cfg_entry_point\": f\"{__name__}.pace.anymal_pace_env_cfg:AnymalDPaceEnvCfg\"\n    },\n)\n</code></pre>"},{"location":"tutorials/basics/#designing-the-excitation-trajectory","title":"Designing the Excitation Trajectory","text":"<p>Well-designed trajectories are critical for accurate parameter estimation. PACE provides a script to prototype and validate trajectories before deployment on real hardware:</p> <pre><code>pace-sim2real/scripts/pace/data_collection.py\n</code></pre> <p>The following section temporarily injects example parameters for testing and can be omitted.</p> <pre><code>armature = torch.tensor([0.1] * len(joint_ids), device=env.unwrapped.device).unsqueeze(0)\ndamping = torch.tensor([4.5] * len(joint_ids), device=env.unwrapped.device).unsqueeze(0)\nfriction = torch.tensor([0.05] * len(joint_ids), device=env.unwrapped.device).unsqueeze(0)\nbias = torch.tensor([0.05] * 12, device=env.unwrapped.device).unsqueeze(0)\ntime_lag = torch.tensor([[5]], dtype=torch.int, device=env.unwrapped.device)\n</code></pre> <p>Trajectory design is controlled through:</p> <ul> <li><code>trajectory_direction</code>: symmetric joint motion to cancel base forces</li> <li><code>trajectory_bias</code>: center of oscillation</li> <li><code>trajectory_scale</code>: oscillation amplitude</li> </ul> <pre><code>duration = args_cli.duration  # seconds\nsample_rate = 1 / env.unwrapped.sim.get_physics_dt()  # Hz\nnum_steps = int(duration * sample_rate)\nt = torch.linspace(0, duration, steps=num_steps, device=env.unwrapped.device)\nf0 = args_cli.min_frequency  # Hz\nf1 = args_cli.max_frequency  # Hz\n\n# Linear chirp: phase = 2*pi*(f0*t + (f1-f0)/(2*duration)*t^2)\nphase = 2 * pi * (f0 * t + ((f1 - f0) / (2 * duration)) * t ** 2)\nchirp_signal = torch.sin(phase)\n\ntrajectory = torch.zeros((num_steps, len(joint_ids)), device=env.unwrapped.device)\ntrajectory[:, :] = chirp_signal.unsqueeze(-1)\ntrajectory_directions = torch.tensor(\n    [1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0],\n    device=env.unwrapped.device\n)\ntrajectory_bias = torch.tensor(\n    [0.0, 0.4, 0.8] * 4,\n    device=env.unwrapped.device\n)\ntrajectory_scale = torch.tensor(\n    [0.25, 0.5, -2.0] * 4,\n    device=env.unwrapped.device\n)\ntrajectory[:, joint_ids] = (trajectory[:, joint_ids] + trajectory_bias.unsqueeze(0)) * trajectory_directions.unsqueeze(0) * trajectory_scale.unsqueeze(0)\n</code></pre> <p>While chirp-based signals provide a practical baseline, more advanced trajectory optimization approaches may further improve system identification quality.</p>"},{"location":"tutorials/basics/#evolutionary-parameter-fitting","title":"Evolutionary Parameter Fitting","text":"<p>Once data collection is complete and stored in the correct directory, launch the optimization using:</p> <pre><code>cd ~/pace-sim2real\npython scripts/pace/fit.py --headless --num_envs=4096 --task=Isaac-Pace-Anymal-D-v0\n</code></pre> <p>This process utilizes the <code>CMAESOptimizer</code> located at:</p> <pre><code>pace-sim2real/source/pace_sim2real/pace_sim2real/optim/cma_es.py\n</code></pre>"},{"location":"tutorials/basics/#logging-and-optimization-inspection","title":"Logging and Optimization Inspection","text":"<p>All optimization logs are stored under:</p> <pre><code>pace-sim2real/logs/pace/anymal_d_sim\n</code></pre> <p>Key files include:</p> <ul> <li><code>config.pt</code>: full configuration and dataset metadata</li> <li><code>best_trajectory.pt</code>: best simulated joint trajectory</li> <li><code>mean_xxx.pt</code>: mean parameter estimates per iteration</li> </ul> <p>If logging of the full optimization process is enabled:</p> <pre><code>save_optimization_process = True\n</code></pre> <p>Additional files include:</p> <ul> <li><code>progress.pt</code>: best scores and complete parameter history over the iterations</li> </ul>"},{"location":"tutorials/basics/#comparing-trajectories","title":"Comparing Trajectories","text":"<p>During or after optimization, visualize the current best trajectory using:</p> <pre><code>python scripts/pace/plot_trajectory.py --plot_trajectory --robot_name=anymal_d_sim\n</code></pre> <p>After completion, include <code>--plot_score</code> to visualize convergence behavior over iterations if desired.</p>"},{"location":"tutorials/basics/#deploying-on-hardware","title":"Deploying on Hardware","text":"<p>To use the identified parameters in your learning environment, integrate the PACE actuator model into your project.</p> <p>Copy the following files (or directly import them in your learning environment):</p> <ul> <li><code>pace-sim2real/source/pace_sim2real/pace_sim2real/utils/pace_actuator.py</code></li> <li><code>pace-sim2real/source/pace_sim2real/pace_sim2real/utils/pace_actuator_cfg.py</code></li> </ul> <p>Use the following procedure:</p> <ol> <li>Import <code>PaceDCMotorCfg</code> (and optionally <code>PaceDCMotor</code>) into your project.     <pre><code>from pace_sim2real.utils import PaceDCMotorCfg, PaceDCMotor\n</code></pre></li> <li> <p>During initialization, set:</p> <ul> <li><code>max_delay</code></li> <li><code>encoder_bias</code></li> </ul> <p>using the values obtained from the parameter identification step.</p> </li> <li> <p>Prior to training, configure your articulation object with the optimized parameters for:</p> <ul> <li><code>joint_armature</code></li> <li><code>joint_viscous_friction</code></li> <li><code>joint_friction</code></li> </ul> </li> </ol> <p>This concludes the complete workflow for creating a custom PACE environment and performing evolutionary system identification. Adjust parameters iteratively based on observed performance and physical plausibility to achieve optimal sim-to-real alignment.</p>"},{"location":"tutorials/best_practice/","title":"Best Practices for CMA-ES Optimization in PACE","text":"<p>This guide documents recommended practices for safe, efficient, and reliable use of the CMA-ES optimizer in PACE. It targets standard users who want robust results without diving into deep algorithmic customization.</p> <p>These recommendations are derived from practical experience with system identification on real legged robots and large-scale simulation campaigns.</p>"},{"location":"tutorials/best_practice/#1-choose-bounds-carefully","title":"1. Choose Bounds Carefully","text":"<p>Parameter bounds define the effective search space of CMA-ES and have the strongest influence on convergence quality.</p>"},{"location":"tutorials/best_practice/#recommendations","title":"Recommendations","text":"<ul> <li>Base bounds on physically plausible values, not theoretical extremes.</li> <li>Use datasheets, prior experiments, or hand tuning as reference.</li> <li>Avoid overly wide bounds: this slows convergence and destabilizes covariance adaptation.</li> <li>Avoid overly tight bounds: this leads to local minima and poor generalization.</li> </ul>"},{"location":"tutorials/best_practice/#2-population-size-vs-runtime-trade-off","title":"2. Population Size vs Runtime Trade-off","text":"<p>Population size directly controls exploration quality and computational cost.</p>"},{"location":"tutorials/best_practice/#practical-guidance","title":"Practical guidance","text":"<ul> <li>256\u2013512: fast prototyping</li> <li>512\u20132048: standard identification</li> <li>2048\u20134096+: high-fidelity identification / publication-grade results</li> </ul> <p>Scaling behavior:</p> <pre><code>Runtime \u221d population_size \u00d7 trajectory_length\nGPU memory \u221d population_size \u00d7 time_steps \u00d7 joints\n</code></pre> <p>Note: Since we parallelize simulation environments, runtime does not scale linearly with population size and depends on your GPU hardware.</p>"},{"location":"tutorials/best_practice/#3-avoid-overfitting-to-a-single-trajectory","title":"3. Avoid Overfitting to a Single Trajectory","text":"<p>A perfect fit to one trajectory does not guarantee real-world performance.</p>"},{"location":"tutorials/best_practice/#always-validate-on","title":"Always validate on:","text":"<ul> <li>Different excitation signals (e.g. varying chirp frequencies)</li> <li>Changed amplitudes</li> <li>Phase-shifted trajectories</li> <li>Different PD-gains</li> </ul> <p>Good identification minimizes error across a family of trajectories, not one sequence.</p>"},{"location":"tutorials/best_practice/#4-understand-delay-optimization-limitations","title":"4. Understand Delay Optimization Limitations","text":"<p>In PACE, delay is internally discretized to an integer value.</p> <p>Consequences:</p> <ul> <li>Optimization landscape is discontinuous</li> <li>Small changes in parameters may cause sudden behavior jumps</li> <li>Convergence may appear noisy or unstable</li> </ul>"},{"location":"tutorials/best_practice/#recommendation","title":"Recommendation","text":"<p>Use conservative delay bounds and monitor delay histograms during training.</p>"},{"location":"tutorials/best_practice/#5-always-start-in-simulation","title":"5. Always Start in Simulation","text":"<p>Never apply unverified parameters directly to hardware.</p>"},{"location":"tutorials/best_practice/#mandatory-workflow","title":"Mandatory workflow","text":"<ol> <li>Identify parameters in simulation</li> <li>Validate on multiple trajectories</li> <li>Apply conservative limits</li> <li>Gradually deploy to hardware</li> <li>Monitor safety metrics (torque, temperature, velocity)</li> </ol>"},{"location":"tutorials/best_practice/#6-monitor-tensorboard-actively","title":"6. Monitor TensorBoard Actively","text":"<p>TensorBoard is not optional \u2014 it is a diagnostic tool.</p>"},{"location":"tutorials/best_practice/#healthy-convergence-patterns","title":"Healthy convergence patterns","text":"<ul> <li>Histogram narrowing over iterations</li> <li>Slowly improving best score</li> <li>Stable mean evolution</li> </ul>"},{"location":"tutorials/best_practice/#warning-signs","title":"Warning signs","text":"<ul> <li>Histogram collapse early (premature convergence)</li> <li>Multi-modal distributions persisting</li> <li>Oscillating delay or bias values</li> </ul>"},{"location":"tutorials/best_practice/#7-reproducibility-logging","title":"7. Reproducibility &amp; Logging","text":"<p>For traceable experiments, always log:</p> <ul> <li>Parameter bounds</li> <li>Trajectory settings</li> <li>Robot model version</li> </ul> <p>Even with fixed seeds:</p> <ul> <li>Floating-point noise may cause tiny variations</li> <li>Physics determinism may depend on hardware and driver versions</li> </ul>"},{"location":"tutorials/best_practice/#8-memory-performance-awareness","title":"8. Memory &amp; Performance Awareness","text":"<p>PACE stores population trajectories and histories for analysis.</p> <p>Be mindful that:</p> <pre><code>Memory \u2248 iterations \u00d7 population \u00d7 time_steps \u00d7 joints\n</code></pre> <p>Large experiments can exceed GPU memory silently.</p>"},{"location":"tutorials/best_practice/#recommendations_1","title":"Recommendations","text":"<ul> <li>Reduce <code>save_interval</code></li> <li>Disable full history unless needed</li> <li>Monitor GPU usage during early runs</li> </ul>"},{"location":"tutorials/best_practice/#9-hardware-safety-checklist","title":"9. Hardware Safety Checklist","text":"<p>Before deploying to real robots:</p> <ul> <li>\u2705 Simulator behavior stable</li> <li>\u2705 No joint oscillations</li> <li>\u2705 Torque below safe thresholds</li> <li>\u2705 Temperatures monitored</li> <li>\u2705 Emergency stop tested</li> </ul>"},{"location":"tutorials/best_practice/#10-practical-workflow-summary","title":"10. Practical Workflow Summary","text":"<p>Recommended pipeline:</p> <ol> <li>Define physically sound bounds</li> <li>Run CMA-ES in simulation</li> <li>Monitor convergence and histograms</li> <li>Validate on unseen motions</li> <li>Gradually introduce to hardware</li> <li>Iterate and refine</li> </ol>"},{"location":"tutorials/best_practice/#final-note","title":"Final Note","text":"<p>CMA-ES in PACE is a powerful tool \u2014 but with power comes responsibility. Proper bounds, active monitoring, and careful validation are essential for safe and meaningful results. Following these best practices will significantly increase both identification quality and long-term hardware reliability.</p> <p>If you deviate from these guidelines, do so intentionally and document your rationale.</p>"}]}